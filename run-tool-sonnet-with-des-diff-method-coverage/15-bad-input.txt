
# Description

# PR

Use the separate pass for # fmt: off on all code
This removes the hacky exception-based handling that didn't work across
statement boundaries.

Fixes #335

# Issue #335 - fmt: off is ignored after first function

Fedora 28, master black

Trying to work around #334 and ran into this.

Minimized test source:

import pytest

TmSt = 1
TmEx = 2

# fmt: off

# Test data:
#   Position, Volume, State, TmSt/TmEx/None, [call, [arg1...]]

@pytest.mark.parametrize('test', [

    # Test don't manage the volume
    [
        ('stuff', 'in')
    ],
])
def test_fader(test):
    pass

def check_fader(test):
    pass

def test_calculate_fades():
    calcs = [
        # one is zero/none
        (0, 4, 0, 0, 10,        0, 0, 6, 10),
        (None, 4, 0, 0, 10,     0, 0, 6, 10),
    ]

# fmt: on
Result:

import pytest

TmSt = 1
TmEx = 2

# fmt: off

# Test data:
#   Position, Volume, State, TmSt/TmEx/None, [call, [arg1...]]

@pytest.mark.parametrize('test', [

    # Test don't manage the volume
    [
        ('stuff', 'in')
    ],
])
def test_fader(test):
    pass


def check_fader(test):
    pass


def test_calculate_fades():
    calcs = [
        # one is zero/none
        (0, 4, 0, 0, 10, 0, 0, 6, 10),
        (None, 4, 0, 0, 10, 0, 0, 6, 10),
    ]


# fmt: on

Note that there are two things ignored:

Inserted extra lines between functions
the list of tuples in test_calculate_fades was reformatted


# Diff

diff --git a/black.py b/black.py
index 7682f7c..7e39c92 100644
--- a/black.py
+++ b/black.py
@@ -29,7 +29,6 @@ from typing import (
     Sequence,
     Set,
     Tuple,
-    Type,
     TypeVar,
     Union,
     cast,
@@ -90,34 +89,6 @@ class CannotSplit(Exception):
     """
 
 
-class FormatError(Exception):
-    """Base exception for `# fmt: on` and `# fmt: off` handling.
-
-    It holds the number of bytes of the prefix consumed before the format
-    control comment appeared.
-    """
-
-    def __init__(self, consumed: int) -> None:
-        super().__init__(consumed)
-        self.consumed = consumed
-
-    def trim_prefix(self, leaf: Leaf) -> None:
-        leaf.prefix = leaf.prefix[self.consumed :]
-
-    def leaf_from_consumed(self, leaf: Leaf) -> Leaf:
-        """Returns a new Leaf from the consumed part of the prefix."""
-        unformatted_prefix = leaf.prefix[: self.consumed]
-        return Leaf(token.NEWLINE, unformatted_prefix)
-
-
-class FormatOn(FormatError):
-    """Found a comment like `# fmt: on` in the file."""
-
-
-class FormatOff(FormatError):
-    """Found a comment like `# fmt: off` in the file."""
-
-
 class WriteBack(Enum):
     NO = 0
     YES = 1
@@ -759,13 +730,15 @@ class DebugVisitor(Visitor[T]):
             out(f" {node.value!r}", fg="blue", bold=False)
 
     @classmethod
-    def show(cls, code: str) -> None:
+    def show(cls, code: Union[str, Leaf, Node]) -> None:
         """Pretty-print the lib2to3 AST of a given string of `code`.
 
         Convenience method for debugging.
         """
         v: DebugVisitor[None] = DebugVisitor()
-        list(v.visit(lib2to3_parse(code)))
+        if isinstance(code, str):
+            code = lib2to3_parse(code)
+        list(v.visit(code))
 
 
 KEYWORDS = set(keyword.kwlist)
@@ -1306,55 +1279,6 @@ class Line:
         return bool(self.leaves or self.comments)
 
 
-class UnformattedLines(Line):
-    """Just like :class:`Line` but stores lines which aren't reformatted."""
-
-    def append(self, leaf: Leaf, preformatted: bool = True) -> None:
-        """Just add a new `leaf` to the end of the lines.
-
-        The `preformatted` argument is ignored.
-
-        Keeps track of indentation `depth`, which is useful when the user
-        says `# fmt: on`. Otherwise, doesn't do anything with the `leaf`.
-        """
-        try:
-            list(generate_comments(leaf))
-        except FormatOn as f_on:
-            self.leaves.append(f_on.leaf_from_consumed(leaf))
-            raise
-
-        self.leaves.append(leaf)
-        if leaf.type == token.INDENT:
-            self.depth += 1
-        elif leaf.type == token.DEDENT:
-            self.depth -= 1
-
-    def __str__(self) -> str:
-        """Render unformatted lines from leaves which were added with `append()`.
-
-        `depth` is not used for indentation in this case.
-        """
-        if not self:
-            return "\n"
-
-        res = ""
-        for leaf in self.leaves:
-            res += str(leaf)
-        return res
-
-    def append_comment(self, comment: Leaf) -> bool:
-        """Not implemented in this class. Raises `NotImplementedError`."""
-        raise NotImplementedError("Unformatted lines don't store comments separately.")
-
-    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
-        """Does nothing and returns False."""
-        return False
-
-    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:
-        """Does nothing and returns False."""
-        return False
-
-
 @dataclass
 class EmptyLineTracker:
     """Provides a stateful method that returns the number of potential extra
@@ -1376,9 +1300,6 @@ class EmptyLineTracker:
         This is for separating `def`, `async def` and `class` with extra empty
         lines (two on module-level).
         """
-        if isinstance(current_line, UnformattedLines):
-            return 0, 0
-
         before, after = self._maybe_empty_lines(current_line)
         before -= self.previous_after
         self.previous_after = after
@@ -1482,7 +1403,7 @@ class LineGenerator(Visitor[Line]):
     current_line: Line = Factory(Line)
     remove_u_prefix: bool = False
 
-    def line(self, indent: int = 0, type: Type[Line] = Line) -> Iterator[Line]:
+    def line(self, indent: int = 0) -> Iterator[Line]:
         """Generate a line.
 
         If the line is empty, only emit if it makes sense.
@@ -1491,67 +1412,39 @@ class LineGenerator(Visitor[Line]):
         If any lines were generated, set up a new current_line.
         """
         if not self.current_line:
-            if self.current_line.__class__ == type:
-                self.current_line.depth += indent
-            else:
-                self.current_line = type(depth=self.current_line.depth + indent)
+            self.current_line.depth += indent
             return  # Line is empty, don't emit. Creating a new one unnecessary.
 
         complete_line = self.current_line
-        self.current_line = type(depth=complete_line.depth + indent)
+        self.current_line = Line(depth=complete_line.depth + indent)
         yield complete_line
 
-    def visit(self, node: LN) -> Iterator[Line]:
-        """Main method to visit `node` and its children.
-
-        Yields :class:`Line` objects.
-        """
-        if isinstance(self.current_line, UnformattedLines):
-            # File contained `# fmt: off`
-            yield from self.visit_unformatted(node)
-
-        else:
-            yield from super().visit(node)
-
     def visit_default(self, node: LN) -> Iterator[Line]:
         """Default `visit_*()` implementation. Recurses to children of `node`."""
         if isinstance(node, Leaf):
             any_open_brackets = self.current_line.bracket_tracker.any_open_brackets()
-            try:
-                for comment in generate_comments(node):
-                    if any_open_brackets:
-                        # any comment within brackets is subject to splitting
-                        self.current_line.append(comment)
-                    elif comment.type == token.COMMENT:
-                        # regular trailing comment
-                        self.current_line.append(comment)
-                        yield from self.line()
-
-                    else:
-                        # regular standalone comment
-                        yield from self.line()
-
-                        self.current_line.append(comment)
-                        yield from self.line()
-
-            except FormatOff as f_off:
-                f_off.trim_prefix(node)
-                yield from self.line(type=UnformattedLines)
-                yield from self.visit(node)
-
-            except FormatOn as f_on:
-                # This only happens here if somebody says "fmt: on" multiple
-                # times in a row.
-                f_on.trim_prefix(node)
-                yield from self.visit_default(node)
+            for comment in generate_comments(node):
+                if any_open_brackets:
+                    # any comment within brackets is subject to splitting
+                    self.current_line.append(comment)
+                elif comment.type == token.COMMENT:
+                    # regular trailing comment
+                    self.current_line.append(comment)
+                    yield from self.line()
 
-            else:
-                normalize_prefix(node, inside_brackets=any_open_brackets)
-                if self.normalize_strings and node.type == token.STRING:
-                    normalize_string_prefix(node, remove_u_prefix=self.remove_u_prefix)
-                    normalize_string_quotes(node)
-                if node.type not in WHITESPACE:
-                    self.current_line.append(node)
+                else:
+                    # regular standalone comment
+                    yield from self.line()
+
+                    self.current_line.append(comment)
+                    yield from self.line()
+
+            normalize_prefix(node, inside_brackets=any_open_brackets)
+            if self.normalize_strings and node.type == token.STRING:
+                normalize_string_prefix(node, remove_u_prefix=self.remove_u_prefix)
+                normalize_string_quotes(node)
+            if node.type not in WHITESPACE:
+                self.current_line.append(node)
         yield from super().visit_default(node)
 
     def visit_INDENT(self, node: Node) -> Iterator[Line]:
@@ -1648,23 +1541,10 @@ class LineGenerator(Visitor[Line]):
         yield from self.visit_default(leaf)
         yield from self.line()
 
-    def visit_unformatted(self, node: LN) -> Iterator[Line]:
-        """Used when file contained a `# fmt: off`."""
-        if isinstance(node, Node):
-            for child in node.children:
-                yield from self.visit(child)
-
-        else:
-            try:
-                self.current_line.append(node)
-            except FormatOn as f_on:
-                f_on.trim_prefix(node)
-                yield from self.line()
-                yield from self.visit(node)
-
-            if node.type == token.ENDMARKER:
-                # somebody decided not to put a final `# fmt: on`
-                yield from self.line()
+    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
+        if not self.current_line.bracket_tracker.any_open_brackets():
+            yield from self.line()
+        yield from self.visit_default(leaf)
 
     def __attrs_post_init__(self) -> None:
         """You are in a twisty little maze of passages."""
@@ -1969,6 +1849,9 @@ def container_of(leaf: Leaf) -> LN:
         if parent.children[0].prefix != same_prefix:
             break
 
+        if parent.type == syms.file_input:
+            break
+
         if parent.type in SURROUNDED_BY_BRACKETS:
             break
 
@@ -2106,16 +1989,6 @@ def generate_comments(leaf: LN) -> Iterator[Leaf]:
     """
     for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
         yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
-        if pc.value in FMT_ON:
-            raise FormatOn(pc.consumed)
-
-        if pc.value in FMT_OFF:
-            if pc.type == STANDALONE_COMMENT:
-                raise FormatOff(pc.consumed)
-
-            prev = preceding_leaf(leaf)
-            if not prev or prev.type in WHITESPACE:  # standalone comment in disguise
-                raise FormatOff(pc.consumed)
 
 
 @dataclass
@@ -2188,7 +2061,7 @@ def split_line(
     If `py36` is True, splitting may generate syntax that is only compatible
     with Python 3.6 and later.
     """
-    if isinstance(line, UnformattedLines) or line.is_comment:
+    if line.is_comment:
         yield line
         return
 
@@ -2680,28 +2553,29 @@ def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
 
 
 def normalize_fmt_off(node: Node) -> None:
-    """Allow `# fmt: off`/`# fmt: on` within bracket pairs.
-
-    Ignores `# fmt: off` and `# fmt: on` outside of brackets.
-
-    Raises :exc:`SyntaxError` if no matching `# fmt: on` is found for a `# fmt: off`
-    given inside brackets.
-    """
+    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
     try_again = True
     while try_again:
-        try_again = hide_fmt_off(node)
+        try_again = convert_one_fmt_off_pair(node)
 
 
-def hide_fmt_off(node: Node) -> bool:
-    bt = BracketTracker()
-    for leaf in node.leaves():
-        bt.mark(leaf)
-        if bt.depth == 0:
-            continue
+def convert_one_fmt_off_pair(node: Node) -> bool:
+    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
 
+    Returns True if a pair was converted.
+    """
+    for leaf in node.leaves():
         previous_consumed = 0
         for comment in list_comments(leaf.prefix, is_endmarker=False):
             if comment.value in FMT_OFF:
+                # We only want standalone comments. If there's no previous leaf or
+                # the previous leaf is indentation, it's a standalone comment in
+                # disguise.
+                if comment.type != STANDALONE_COMMENT:
+                    prev = preceding_leaf(leaf)
+                    if prev and prev.type not in WHITESPACE:
+                        continue
+
                 ignored_nodes = list(generate_ignored_nodes(leaf))
                 first = ignored_nodes[0]  # Can be a container node with the `leaf`.
                 parent = first.parent
@@ -2710,6 +2584,10 @@ def hide_fmt_off(node: Node) -> bool:
                 hidden_value = (
                     comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
                 )
+                if hidden_value.endswith("\n"):
+                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
+                    # leaf (possibly followed by a DEDENT).
+                    hidden_value = hidden_value[:-1]
                 first_idx = None
                 for ignored in ignored_nodes:
                     index = ignored.remove()
@@ -2733,8 +2611,12 @@ def hide_fmt_off(node: Node) -> bool:
 
 
 def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
+    """Starting from the container of `leaf`, generate all leaves until `# fmt: on`.
+
+    Stops at the end of the block.
+    """
     container: Optional[LN] = container_of(leaf)
-    while container is not None:
+    while container is not None and container.type != token.ENDMARKER:
         for comment in list_comments(container.prefix, is_endmarker=False):
             if comment.value in FMT_ON:
                 return


# Method Trace

blib2to3.pgen2.tokenize.any->blib2to3.pgen2.tokenize.group
blib2to3.pgen2.tokenize.maybe->blib2to3.pgen2.tokenize.group
blib2to3.pgen2.tokenize._combinations->blib2to3.pgen2.tokenize.<genexpr>
blib2to3.pygram.initialize->blib2to3.pgen2.driver.load_packaged_grammar
blib2to3.pygram.initialize->blib2to3.pygram.__init__
blib2to3.pygram.initialize->blib2to3.pgen2.grammar.copy
blib2to3.pgen2.driver.load_packaged_grammar->blib2to3.pgen2.driver._generate_pickle_name
blib2to3.pgen2.driver.load_packaged_grammar->blib2to3.pgen2.driver.load_grammar
blib2to3.pgen2.driver.load_packaged_grammar->genericpath.isfile
blib2to3.pgen2.driver._generate_pickle_name->posixpath.join
blib2to3.pgen2.driver._generate_pickle_name->posixpath.splitext
blib2to3.pgen2.driver._generate_pickle_name->posixpath.basename
blib2to3.pgen2.driver.load_grammar->logging.getLogger
blib2to3.pgen2.driver.load_grammar->blib2to3.pgen2.tokenize.generate_tokens
blib2to3.pgen2.driver.load_grammar->logging.info
blib2to3.pgen2.driver.load_grammar->blib2to3.pgen2.driver._newer
blib2to3.pgen2.driver.load_grammar->blib2to3.pgen2.grammar.dump
blib2to3.pgen2.driver.load_grammar->blib2to3.pgen2.pgen.generate_grammar
blib2to3.pgen2.driver._newer->genericpath.exists
blib2to3.pgen2.pgen.generate_grammar->blib2to3.pgen2.pgen.__init__
blib2to3.pgen2.pgen.generate_grammar->blib2to3.pgen2.pgen.make_grammar
blib2to3.pgen2.pgen.__init__->codecs.__init__
blib2to3.pgen2.pgen.__init__->blib2to3.pgen2.pgen.parse
blib2to3.pgen2.pgen.__init__->_bootlocale.getpreferredencoding
blib2to3.pgen2.pgen.__init__->blib2to3.pgen2.pgen.gettoken
blib2to3.pgen2.pgen.__init__->blib2to3.pgen2.pgen.addfirstsets
blib2to3.pgen2.pgen.gettoken->blib2to3.pgen2.tokenize.generate_tokens
blib2to3.pgen2.tokenize.generate_tokens->codecs.getstate
blib2to3.pgen2.tokenize.generate_tokens->codecs.decode
blib2to3.pgen2.pgen.parse->blib2to3.pgen2.pgen.simplify_dfa
blib2to3.pgen2.pgen.parse->blib2to3.pgen2.pgen.expect
blib2to3.pgen2.pgen.parse->blib2to3.pgen2.pgen.make_dfa
blib2to3.pgen2.pgen.parse->blib2to3.pgen2.pgen.parse_rhs
blib2to3.pgen2.pgen.expect->blib2to3.pgen2.pgen.gettoken
blib2to3.pgen2.pgen.parse_rhs->blib2to3.pgen2.pgen.__init__
blib2to3.pgen2.pgen.parse_rhs->blib2to3.pgen2.pgen.gettoken
blib2to3.pgen2.pgen.parse_rhs->blib2to3.pgen2.pgen.parse_alt
blib2to3.pgen2.pgen.parse_rhs->blib2to3.pgen2.pgen.addarc
blib2to3.pgen2.pgen.parse_alt->blib2to3.pgen2.pgen.addarc
blib2to3.pgen2.pgen.parse_alt->blib2to3.pgen2.pgen.parse_item
blib2to3.pgen2.pgen.parse_item->blib2to3.pgen2.pgen.expect
blib2to3.pgen2.pgen.parse_item->blib2to3.pgen2.pgen.parse_rhs
blib2to3.pgen2.pgen.parse_item->blib2to3.pgen2.pgen.gettoken
blib2to3.pgen2.pgen.parse_item->blib2to3.pgen2.pgen.parse_atom
blib2to3.pgen2.pgen.parse_item->blib2to3.pgen2.pgen.addarc
blib2to3.pgen2.pgen.parse_atom->blib2to3.pgen2.pgen.expect
blib2to3.pgen2.pgen.parse_atom->blib2to3.pgen2.pgen.parse_rhs
blib2to3.pgen2.pgen.parse_atom->blib2to3.pgen2.pgen.gettoken
blib2to3.pgen2.pgen.parse_atom->blib2to3.pgen2.pgen.addarc
blib2to3.pgen2.pgen.parse_atom->blib2to3.pgen2.pgen.__init__
blib2to3.pgen2.pgen.make_dfa->blib2to3.pgen2.pgen.addclosure
blib2to3.pgen2.pgen.make_dfa->blib2to3.pgen2.pgen.closure
blib2to3.pgen2.pgen.make_dfa->blib2to3.pgen2.pgen.__init__
blib2to3.pgen2.pgen.make_dfa->blib2to3.pgen2.pgen.addarc
blib2to3.pgen2.pgen.closure->blib2to3.pgen2.pgen.addclosure
blib2to3.pgen2.pgen.addclosure->blib2to3.pgen2.pgen.addclosure
blib2to3.pgen2.pgen.simplify_dfa->blib2to3.pgen2.pgen.unifystate
blib2to3.pgen2.pgen.simplify_dfa->blib2to3.pgen2.pgen.__eq__
blib2to3.pgen2.pgen.addfirstsets->blib2to3.pgen2.pgen.calcfirst
blib2to3.pgen2.pgen.calcfirst->blib2to3.pgen2.pgen.calcfirst
blib2to3.pgen2.pgen.make_grammar->blib2to3.pgen2.grammar.__init__
blib2to3.pgen2.pgen.make_grammar->blib2to3.pgen2.pgen.make_first
blib2to3.pgen2.pgen.make_grammar->blib2to3.pgen2.pgen.make_label
blib2to3.pgen2.pgen.make_grammar->blib2to3.pgen2.pgen.__eq__
blib2to3.pgen2.pgen.make_first->blib2to3.pgen2.pgen.make_label
blib2to3.pgen2.pgen.make_label->blib2to3.pgen2.pgen.<module>
blib2to3.pgen2.grammar.copy->blib2to3.pgen2.grammar.__init__
black.dont_increase_indentation->functools.wraps
black.dont_increase_indentation->typing.inner
black.dont_increase_indentation->functools.update_wrapper
black.format_str->black.__str__
black.format_str->black.maybe_empty_lines
black.format_str->enum.__and__
black.format_str->black.is_python36
black.format_str->.__init__
black.format_str->enum.__bool__
black.format_str->typing.__new__
black.format_str->black.visit
black.format_str->black.get_future_imports
black.format_str->black.lib2to3_parse
black.format_str->black.normalize_fmt_off
black.format_str->black.split_line
black.lib2to3_parse->blib2to3.pgen2.tokenize.generate_tokens
black.lib2to3_parse->blib2to3.pgen2.driver.parse_string
black.lib2to3_parse->blib2to3.pgen2.driver.__init__
blib2to3.pgen2.driver.__init__->logging.getLogger
blib2to3.pgen2.driver.parse_string->blib2to3.pgen2.driver.parse_tokens
blib2to3.pgen2.driver.parse_tokens->blib2to3.pgen2.parse.addtoken
blib2to3.pgen2.driver.parse_tokens->blib2to3.pgen2.parse.setup
blib2to3.pgen2.driver.parse_tokens->blib2to3.pgen2.tokenize.generate_tokens
blib2to3.pgen2.driver.parse_tokens->blib2to3.pgen2.driver._partially_consume_prefix
blib2to3.pgen2.driver.parse_tokens->blib2to3.pgen2.parse.__init__
blib2to3.pgen2.driver.parse_tokens->logging.debug
blib2to3.pgen2.parse.addtoken->blib2to3.pgen2.parse.pop
blib2to3.pgen2.parse.addtoken->blib2to3.pgen2.parse.classify
blib2to3.pgen2.parse.addtoken->blib2to3.pgen2.parse.push
blib2to3.pgen2.parse.addtoken->blib2to3.pgen2.parse.shift
blib2to3.pgen2.parse.shift->blib2to3.pytree.convert
blib2to3.pytree.convert->blib2to3.pytree.__new__
blib2to3.pytree.convert->blib2to3.pytree.__init__
blib2to3.pgen2.parse.pop->blib2to3.pytree.convert
blib2to3.pytree.__init__->blib2to3.pytree.invalidate_sibling_maps
black.is_python36->blib2to3.pytree.pre_order
blib2to3.pytree.pre_order->blib2to3.pytree.pre_order
black.normalize_fmt_off->black.convert_one_fmt_off_pair
black.convert_one_fmt_off_pair->blib2to3.pytree.insert_child
black.convert_one_fmt_off_pair->blib2to3.pytree.leaves
black.convert_one_fmt_off_pair->black.list_comments
black.convert_one_fmt_off_pair->blib2to3.pytree.prefix
black.convert_one_fmt_off_pair->black.<genexpr>
black.convert_one_fmt_off_pair->black.generate_ignored_nodes
black.convert_one_fmt_off_pair->blib2to3.pytree.__init__
black.convert_one_fmt_off_pair->blib2to3.pytree.remove
black.convert_one_fmt_off_pair->blib2to3.pytree.__new__
blib2to3.pytree.leaves->blib2to3.pytree.leaves
black.list_comments->black.make_comment
black.list_comments->.__init__
black.generate_ignored_nodes->blib2to3.pytree.prefix
black.generate_ignored_nodes->black.container_of
black.generate_ignored_nodes->blib2to3.pytree.next_sibling
black.container_of->blib2to3.pytree.prefix
blib2to3.pytree.prefix->blib2to3.pytree.prefix
blib2to3.pytree.prefix->blib2to3.pytree.changed
blib2to3.pytree.next_sibling->blib2to3.pytree.update_sibling_maps
blib2to3.pytree.changed->blib2to3.pytree.changed
blib2to3.pytree.__unicode__->blib2to3.pytree.prefix
blib2to3.pytree.__unicode__->blib2to3.pytree.__unicode__
blib2to3.pytree.remove->blib2to3.pytree.changed
blib2to3.pytree.remove->blib2to3.pytree.invalidate_sibling_maps
blib2to3.pytree.insert_child->blib2to3.pytree.changed
blib2to3.pytree.insert_child->blib2to3.pytree.invalidate_sibling_maps
black.visit->black.visit_STANDALONE_COMMENT
black.visit->black.visit_stmt
black.visit->black.visit_default
black.visit->black.visit_ENDMARKER
black.visit->blib2to3.pytree.type_repr
black.visit->black.visit_simple_stmt
blib2to3.pytree.type_repr->importlib._bootstrap.parent
black.visit_default->black.generate_comments
black.visit_default->black.visit_default
black.visit_default->black.visit
black.visit_default->black.line
black.visit_default->black.any_open_brackets
black.visit_default->black.append
black.visit_default->black.normalize_prefix
black.visit_simple_stmt->black.visit_default
black.visit_simple_stmt->black.line
black.line->black.__bool__
black.line->.__init__
black.generate_comments->black.list_comments
black.generate_comments->blib2to3.pytree.prefix
black.generate_comments->blib2to3.pytree.__new__
black.generate_comments->blib2to3.pytree.__init__
black.normalize_prefix->blib2to3.pytree.prefix
black.append->black.mark
black.append->black.whitespace
black.append->black.maybe_remove_trailing_comma
black.append->blib2to3.pytree.prefix
black.append->black.is_complex_subscript
black.append->black.append_comment
black.mark->black.is_split_before_delimiter
black.mark->black.maybe_increment_for_loop_variable
black.mark->black.maybe_decrement_after_for_loop_variable
black.mark->black.is_split_after_delimiter
black.mark->black.maybe_increment_lambda_arguments
black.mark->black.maybe_decrement_after_lambda_arguments
black.is_split_before_delimiter->black.is_vararg
black.is_complex_subscript->black.get_open_lsqb
black.whitespace->blib2to3.pytree.prev_sibling
black.whitespace->black.preceding_leaf
blib2to3.pytree.prev_sibling->blib2to3.pytree.update_sibling_maps
black.maybe_empty_lines->black._maybe_empty_lines
black._maybe_empty_lines->black.is_class
black._maybe_empty_lines->black.__bool__
black._maybe_empty_lines->blib2to3.pytree.prefix
black._maybe_empty_lines->black.is_def
black._maybe_empty_lines->black.is_import
black._maybe_empty_lines->black.is_decorator
black.is_decorator->black.__bool__
black.is_class->black.__bool__
black.split_line->black.is_comment
black.split_line->black.__str__
black.split_line->black.is_line_short_enough
black.__str__->black.__bool__
black.__str__->blib2to3.pytree.prefix
black.__str__->blib2to3.pytree.__unicode__
black.is_line_short_enough->black.contains_standalone_comments
black.visit_stmt->black.visit
black.visit_stmt->black.normalize_invisible_parens
black.normalize_invisible_parens->black.is_multiline_string
black.normalize_invisible_parens->blib2to3.pytree.insert_child
black.normalize_invisible_parens->blib2to3.pytree.prefix
black.normalize_invisible_parens->black.is_one_tuple
black.normalize_invisible_parens->blib2to3.pytree.__init__
black.normalize_invisible_parens->blib2to3.pytree.remove
black.normalize_invisible_parens->blib2to3.pytree.__new__
black.preceding_leaf->blib2to3.pytree.prev_sibling
black.is_import->black.__bool__
black.is_import->black.is_import
black.visit_STANDALONE_COMMENT->black.visit_default
black.visit_STANDALONE_COMMENT->black.line
black.visit_STANDALONE_COMMENT->black.any_open_brackets
black.append_comment->black.any_open_brackets
black.visit_ENDMARKER->black.visit_default
black.visit_ENDMARKER->black.line
black.assert_equivalent->typing.inner
black.assert_equivalent->black._v
black.assert_equivalent->ast.parse
black._v->black._v
black.assert_stable->black.format_str

# Coverage

Name                  Stmts   Miss  Cover   Missing
---------------------------------------------------
black.py               1774   1083    39%   99-102, 121-128, 139-162, 295-361, 378-404, 424-473, 489-524, 539-560, 576-586, 613, 628-636, 650, 657-666, 669, 675-676, 713-730, 738-741, 896, 908, 912, 930, 937-941, 950-952, 959-961, 972-974, 981-983, 1018, 1037-1046, 1075, 1084-1085, 1104, 1117, 1127-1128, 1133-1137, 1148-1191, 1199-1200, 1205-1213, 1220-1233, 1237-1242, 1250-1258, 1274, 1320, 1323-1327, 1329, 1344, 1351-1390, 1429, 1432-1433, 1444-1445, 1453-1454, 1461-1468, 1487, 1493-1496, 1502-1507, 1516-1527, 1531-1533, 1537, 1597, 1605, 1611, 1614-1620, 1630, 1636-1662, 1669-1670, 1674-1675, 1679-1692, 1696-1699, 1703-1716, 1720-1729, 1733, 1736-1741, 1744-1748, 1752-1760, 1765, 1769-1770, 1774-1791, 1794-1803, 1806, 1819-1826, 1831-1834, 1847, 1853, 1856, 1871, 1887, 1895, 1902, 1905, 1912, 1922, 1929, 1932, 1935, 1947, 1959, 1962, 2019, 2042, 2047, 2076-2117, 2127-2159, 2173-2255, 2272-2278, 2292-2294, 2306-2360, 2366-2389, 2431-2437, 2448-2504, 2517-2519, 2525, 2528-2531, 2535-2543, 2575-2577, 2622, 2631-2650, 2655, 2666-2677, 2688-2704, 2718-2727, 2738-2746, 2751-2758, 2771-2790, 2799-2802, 2807-2821, 2835, 2842-2849, 2864-2905, 2913, 2917-2924, 2926-2937, 2957-2984, 2997-3014, 3030-3042, 3046-3047, 3050-3051, 3064-3070, 3077-3099, 3115-3116, 3135-3137, 3145-3147, 3156-3157, 3171-3175, 3185-3194, 3199-3203, 3210-3212, 3217-3234, 3243, 3251-3253, 3258-3261, 3271-3284, 3293, 3308-3334, 3344-3423, 3427, 3435-3445, 3450-3451, 3460-3467, 3474-3482, 3486
tests/__init__.py         0      0   100%
tests/test_black.py     916    756    17%   31, 47-48, 59-64, 69-79, 88-89, 93-99, 108-121, 126-130, 133-141, 145-150, 154-159, 162-170, 173-186, 190-195, 199-203, 207-211, 215-219, 222-233, 236-261, 265-269, 273-282, 286-290, 294-298, 302-306, 310-314, 318-322, 326-330, 334-338, 342-346, 350-354, 358-362, 366-370, 374-378, 382-385, 389-393, 397-401, 413-417, 421-425, 428-516, 523-603, 610-693, 700-715, 718-737, 740-757, 764-780, 783-786, 790-806, 809-821, 824-833, 837-856, 859-867, 870-875, 878-880, 883-890, 893-906, 909-913, 917-931, 934-937, 941-956, 959-962, 965-972, 975-983, 986-1002, 1006-1028, 1031-1035, 1038-1054, 1058-1082, 1085-1089, 1092-1105, 1108-1129, 1132-1150, 1153-1155, 1158-1167, 1170-1171, 1175-1214, 1218
---------------------------------------------------
TOTAL                  2690   1839    32%

