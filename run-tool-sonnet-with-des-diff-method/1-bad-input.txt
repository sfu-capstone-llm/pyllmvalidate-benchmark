
# Description

# PR - permits black to run in AWS Lambda:

AWS Lambda and some other virtualized environment may not permit access
to /dev/shm on Linux and as such, trying to use ProcessPoolExecutor will
fail.

As using parallelism is only a 'nice to have' feature of black, if it fails
we gracefully fallback to a monoprocess implementation, which permits black
to finish normally.

should fix #1138 and #776

# Issue #1138 - Feature request: permits to disable parallel run for system without support for it

On some virtualized environment you don't have access to /dev/shm which prevent the use of multi-processing. The most notable use case being AWS Lambda, where /dev/shm is simply not present.

A quick and dirty patch show that simply replacing https://github.com/psf/black/blob/master/black.py#L544 by None
and removing this line https://github.com/psf/black/blob/master/black.py#L559
permits black to run in AWS Lambda, which is a huge win in term of CI (as black fits perfectly the use for serverless, i.e short runtime, low memory consumption, triggered on specific event)

so it could be implemented either (or both) by providing a --no-parallel or by detecting that /dev/shm is not possible (I need to dig on how to do that) and in these case to not use the ProcessPoolExecutor

I can provide the pull request if it seems acceptable to you

# Issue #776 - Concurrency crash

Operating system: Ubuntu Xenial (on Travis)
Python version: 3.6.8
Black version: 19.3b0
Does also happen on master: Haven't tested but when through the commits since the release. No commits seem to touch the codepath we're seeing here.

black crashes on certain system configurations due to multiprocessing. Here is the traceback we're seeing.

|Traceback (most recent call last):
|  File "/usr/local/lib/XXX/virtualenv/bin/black", line 11, in <module>
|    sys.exit(patched_main())
|  File "/usr/local/lib/XXX/virtualenv/lib/python3.6/site-packages/black.py", line 3754, in patched_main
|    main()
|  File "/usr/local/lib/XXX/virtualenv/lib/python3.6/site-packages/click/core.py", line 764, in __call__
|    return self.main(*args, **kwargs)
|  File "/usr/local/lib/XXX/virtualenv/lib/python3.6/site-packages/click/core.py", line 717, in main
|    rv = self.invoke(ctx)
|  File "/usr/local/lib/XXX/virtualenv/lib/python3.6/site-packages/click/core.py", line 956, in invoke
|    return ctx.invoke(self.callback, **ctx.params)
|  File "/usr/local/lib/XXX/virtualenv/lib/python3.6/site-packages/click/core.py", line 555, in invoke
|    return callback(*args, **kwargs)
|  File "/usr/local/lib/XXX/virtualenv/lib/python3.6/site-packages/click/decorators.py", line 17, in new_func
|    return f(get_current_context(), *args, **kwargs)
|  File "/usr/local/lib/XXX/virtualenv/lib/python3.6/site-packages/black.py", line 435, in main
|    executor = ProcessPoolExecutor(max_workers=os.cpu_count())
|  File "/usr/lib/python3.6/concurrent/futures/process.py", line 402, in __init__
|    EXTRA_QUEUED_CALLS)
|  File "/usr/lib/python3.6/multiprocessing/context.py", line 102, in Queue
|    return Queue(maxsize, ctx=self.get_context())
|  File "/usr/lib/python3.6/multiprocessing/queues.py", line 42, in __init__
|    self._rlock = ctx.Lock()
|  File "/usr/lib/python3.6/multiprocessing/context.py", line 67, in Lock
|    return Lock(ctx=self.get_context())
|  File "/usr/lib/python3.6/multiprocessing/synchronize.py", line 162, in __init__
|    SemLock.__init__(self, SEMAPHORE, 1, 1, ctx=ctx)
|  File "/usr/lib/python3.6/multiprocessing/synchronize.py", line 59, in __init__
|    unlink_now)
|OSError: [Errno 30] Read-only file system
This only happens when running black on more than 1 file at a time. There should probably be an option (or codepath which tries to correct this issue) for serial execution.

# Diff

diff --git a/black.py b/black.py
index 2a913fc..fc1597a 100644
--- a/black.py
+++ b/black.py
@@ -618,7 +618,14 @@ def reformat_many(
     if sys.platform == "win32":
         # Work around https://bugs.python.org/issue26903
         worker_count = min(worker_count, 61)
-    executor = ProcessPoolExecutor(max_workers=worker_count)
+    try:
+        executor = ProcessPoolExecutor(max_workers=worker_count)
+    except OSError:
+        # we arrive here if the underlying system does not support multi-processing
+        # like in AWS Lambda, in which case we gracefully fallback to the default
+        # mono-process Executor by using None
+        executor = ProcessPoolExecutor()
+
     try:
         loop.run_until_complete(
             schedule_formatting(
@@ -633,7 +640,8 @@ def reformat_many(
         )
     finally:
         shutdown(loop)
-        executor.shutdown()
+        if executor is not None:
+            pass
 
 
 async def schedule_formatting(
@@ -643,7 +651,7 @@ async def schedule_formatting(
     mode: Mode,
     report: "Report",
     loop: asyncio.AbstractEventLoop,
-    executor: Executor,
+    executor: Optional[Executor],
 ) -> None:
     """Run formatting of `sources` in parallel using the provided `executor`.
 


# Method Trace

blib2to3.pgen2.tokenize.any->blib2to3.pgen2.tokenize.group
blib2to3.pgen2.tokenize.maybe->blib2to3.pgen2.tokenize.group
blib2to3.pgen2.tokenize._combinations->blib2to3.pgen2.tokenize.<genexpr>
blib2to3.pygram.initialize->blib2to3.pgen2.grammar.copy
blib2to3.pygram.initialize->blib2to3.pygram.__init__
blib2to3.pygram.initialize->blib2to3.pgen2.driver.load_packaged_grammar
blib2to3.pygram.initialize->posixpath.dirname
blib2to3.pygram.initialize->posixpath.join
blib2to3.pgen2.driver.load_packaged_grammar->blib2to3.pgen2.driver._generate_pickle_name
blib2to3.pgen2.driver.load_packaged_grammar->blib2to3.pgen2.driver.load_grammar
blib2to3.pgen2.driver.load_packaged_grammar->genericpath.isfile
blib2to3.pgen2.driver._generate_pickle_name->posixpath.basename
blib2to3.pgen2.driver._generate_pickle_name->posixpath.join
blib2to3.pgen2.driver._generate_pickle_name->posixpath.splitext
blib2to3.pgen2.driver.load_grammar->logging.getLogger
blib2to3.pgen2.driver.load_grammar->blib2to3.pgen2.tokenize.generate_tokens
blib2to3.pgen2.driver.load_grammar->blib2to3.pgen2.pgen.generate_grammar
blib2to3.pgen2.driver.load_grammar->logging.info
blib2to3.pgen2.driver.load_grammar->blib2to3.pgen2.driver._newer
blib2to3.pgen2.driver.load_grammar->blib2to3.pgen2.grammar.dump
blib2to3.pgen2.driver._newer->genericpath.exists
blib2to3.pgen2.pgen.generate_grammar->blib2to3.pgen2.pgen.make_grammar
blib2to3.pgen2.pgen.generate_grammar->blib2to3.pgen2.pgen.__init__
blib2to3.pgen2.pgen.__init__->blib2to3.pgen2.pgen.addfirstsets
blib2to3.pgen2.pgen.__init__->blib2to3.pgen2.pgen.gettoken
blib2to3.pgen2.pgen.__init__->_bootlocale.getpreferredencoding
blib2to3.pgen2.pgen.__init__->codecs.__init__
blib2to3.pgen2.pgen.__init__->blib2to3.pgen2.pgen.parse
blib2to3.pgen2.pgen.gettoken->blib2to3.pgen2.tokenize.generate_tokens
blib2to3.pgen2.tokenize.generate_tokens->codecs.decode
blib2to3.pgen2.tokenize.generate_tokens->codecs.getstate
blib2to3.pgen2.pgen.parse->blib2to3.pgen2.pgen.simplify_dfa
blib2to3.pgen2.pgen.parse->blib2to3.pgen2.pgen.make_dfa
blib2to3.pgen2.pgen.parse->blib2to3.pgen2.pgen.expect
blib2to3.pgen2.pgen.parse->blib2to3.pgen2.pgen.parse_rhs
blib2to3.pgen2.pgen.expect->blib2to3.pgen2.pgen.gettoken
blib2to3.pgen2.pgen.parse_rhs->blib2to3.pgen2.pgen.addarc
blib2to3.pgen2.pgen.parse_rhs->blib2to3.pgen2.pgen.gettoken
blib2to3.pgen2.pgen.parse_rhs->blib2to3.pgen2.pgen.parse_alt
blib2to3.pgen2.pgen.parse_rhs->blib2to3.pgen2.pgen.__init__
blib2to3.pgen2.pgen.parse_alt->blib2to3.pgen2.pgen.addarc
blib2to3.pgen2.pgen.parse_alt->blib2to3.pgen2.pgen.parse_item
blib2to3.pgen2.pgen.parse_item->blib2to3.pgen2.pgen.gettoken
blib2to3.pgen2.pgen.parse_item->blib2to3.pgen2.pgen.addarc
blib2to3.pgen2.pgen.parse_item->blib2to3.pgen2.pgen.parse_atom
blib2to3.pgen2.pgen.parse_item->blib2to3.pgen2.pgen.expect
blib2to3.pgen2.pgen.parse_item->blib2to3.pgen2.pgen.parse_rhs
blib2to3.pgen2.pgen.parse_atom->blib2to3.pgen2.pgen.gettoken
blib2to3.pgen2.pgen.parse_atom->blib2to3.pgen2.pgen.addarc
blib2to3.pgen2.pgen.parse_atom->blib2to3.pgen2.pgen.__init__
blib2to3.pgen2.pgen.parse_atom->blib2to3.pgen2.pgen.expect
blib2to3.pgen2.pgen.parse_atom->blib2to3.pgen2.pgen.parse_rhs
blib2to3.pgen2.pgen.make_dfa->blib2to3.pgen2.pgen.addarc
blib2to3.pgen2.pgen.make_dfa->blib2to3.pgen2.pgen.addclosure
blib2to3.pgen2.pgen.make_dfa->blib2to3.pgen2.pgen.__init__
blib2to3.pgen2.pgen.make_dfa->typing.inner
blib2to3.pgen2.pgen.make_dfa->blib2to3.pgen2.pgen.closure
blib2to3.pgen2.pgen.closure->blib2to3.pgen2.pgen.addclosure
blib2to3.pgen2.pgen.addclosure->blib2to3.pgen2.pgen.addclosure
blib2to3.pgen2.pgen.simplify_dfa->blib2to3.pgen2.pgen.__eq__
blib2to3.pgen2.pgen.simplify_dfa->blib2to3.pgen2.pgen.unifystate
blib2to3.pgen2.pgen.addfirstsets->blib2to3.pgen2.pgen.calcfirst
blib2to3.pgen2.pgen.calcfirst->blib2to3.pgen2.pgen.calcfirst
blib2to3.pgen2.pgen.make_grammar->blib2to3.pgen2.pgen.make_first
blib2to3.pgen2.pgen.make_grammar->blib2to3.pgen2.pgen.make_label
blib2to3.pgen2.pgen.make_grammar->blib2to3.pgen2.grammar.__init__
blib2to3.pgen2.pgen.make_grammar->blib2to3.pgen2.pgen.__eq__
blib2to3.pgen2.pgen.make_first->blib2to3.pgen2.pgen.make_label
blib2to3.pgen2.pgen.make_label->blib2to3.pgen2.pgen.<module>
blib2to3.pgen2.grammar.dump->posixpath.dirname
blib2to3.pgen2.grammar.dump->tempfile.NamedTemporaryFile
blib2to3.pgen2.grammar.copy->blib2to3.pgen2.grammar.__init__
black.dont_increase_indentation->typing.inner
black.dont_increase_indentation->functools.update_wrapper
black.dont_increase_indentation->functools.wraps
black.write_cache->pathlib.__reduce__
black.write_cache->tempfile.__getattr__
black.write_cache->tempfile.__enter__
black.write_cache->black.<dictcomp>
black.write_cache->tempfile.__exit__
black.write_cache->pathlib.__fspath__
black.write_cache->black.get_cache_file
black.write_cache->tempfile.func_wrapper
black.write_cache->pathlib.__str__
black.write_cache->pathlib.parent
black.write_cache->tempfile.NamedTemporaryFile
black.write_cache->pathlib.mkdir
black.get_cache_file->black.get_cache_key
black.get_cache_file->pathlib.__truediv__
black.get_cache_info->pathlib.stat
black.read_pyproject_toml->black.parse_pyproject_toml
black.parse_pyproject_toml->black.<dictcomp>
black.parse_pyproject_toml->toml.decoder.load
black.target_version_option_callback->black.<listcomp>
black.main->pathlib.__new__
black.main->black.gen_python_files_in_dir
black.main->pathlib.__hash__
black.main->black.from_configuration
black.main->black.__init__
black.main->black.re_compile_maybe_verbose
black.main->pathlib.is_dir
black.main->black.get_gitignore
black.main->black.path_empty
black.main->black.find_project_root
black.main->black.reformat_many
black.re_compile_maybe_verbose->regex.regex.compile
black.find_project_root->pathlib.exists
black.find_project_root->pathlib.is_file
black.find_project_root->black.<genexpr>
black.find_project_root->collections.abc.__iter__
black.find_project_root->pathlib.is_dir
black.find_project_root->pathlib.__truediv__
black.find_project_root->pathlib.parents
black.get_gitignore->pathlib.is_file
black.get_gitignore->pathlib.__truediv__
black.get_gitignore->pathspec.pathspec.from_lines
black.gen_python_files_in_dir->pathlib.relative_to
black.gen_python_files_in_dir->pathlib.iterdir
black.gen_python_files_in_dir->pathlib.resolve
black.gen_python_files_in_dir->pathlib.is_file
black.gen_python_files_in_dir->pathlib.is_dir
black.gen_python_files_in_dir->pathlib.is_absolute
black.gen_python_files_in_dir->pathspec.pathspec.match_file
black.gen_python_files_in_dir->pathlib.as_posix
black.reformat_many->unittest.mock.__call__
black.reformat_many->asyncio.events.get_event_loop_policy
black.reformat_many->asyncio.events.get_event_loop
