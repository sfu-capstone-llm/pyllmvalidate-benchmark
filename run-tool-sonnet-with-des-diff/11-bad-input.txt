
# Description

# PR - Add support for special comments in multiline functions

This is a starter diff to deal with #282, and I'm happy to iterate on it.

We want to ensure that type comments (https://www.python.org/dev/peps/pep-0484/) for Python 2 are formatted in a valid way, so that we can use Black in our organization.

# Issue #282 - Breaks multiline function type annotation comments

Operating system: Fedora 27 4.13.9-300.fc27.x86_64)
Python version: 3.6.2
Black version: 18.5b1
Does also happen on master: yes

PEP484 was amended (python/typing#186) to extend Python 2 compatible type annotation comments to allow placing each function parameter on a separate line with its own type annotation and the return type at the end. The motivation for this was to be able to write type annotations which would otherwise extend beyond the maximum line limit. But when it will fit in the maximum line length, Black combines all the arguments onto one line, including the type annotations, which become malformed.

Given this input

def f(a,  # type: int
      b,  # type: str
      c,  # type: bool
      ):  # type: (...) -> None
    ...
Black produces this

def f(a, b, c):  # type: int  # type: str  # type: bool  # type: (...) -> None
    ...
which has a malformed type annotation.

I think the correct behaviour would be either leave the function parameters on separate lines (do nothing) or restructure the type annotation like this:

def f(a, b, c):  # (int, str, bool) -> None
    ...
or if the resultant line is too long, this

def f(a, b, c): 
    # (int, str, bool) -> None
    ...
This might deserve a separate issue, but it'd be nice if Black did the reverse as well: given a very long function type annotation on one line, annotate each parameter separately.

# Diff

diff --git a/black.py b/black.py
index 52c5b0c..fb8e474 100644
--- a/black.py
+++ b/black.py
@@ -2112,8 +2112,19 @@ def split_line(
         return
 
     line_str = str(line).strip("\n")
-    if not line.should_explode and is_line_short_enough(
-        line, line_length=line_length, line_str=line_str
+
+    # we don't want to split special comments like type annotations
+    # https://github.com/python/typing/issues/186
+    has_special_comment = False
+    for leaf in line.leaves:
+        for comment in line.comments_after(leaf):
+            if leaf.type == token.COMMA and is_special_comment(comment):
+                has_special_comment = True
+
+    if (
+        has_special_comment
+        and not line.should_explode
+        and is_line_short_enough(line, line_length=line_length, line_str=line_str)
     ):
         yield line
         return
@@ -2462,6 +2473,16 @@ def is_import(leaf: Leaf) -> bool:
     )
 
 
+def is_special_comment(leaf: Leaf) -> bool:
+    """Return True if the given leaf is a special comment.
+    Only returns true for type comments for now."""
+    t = leaf.type
+    v = leaf.value
+    return bool(
+        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
+    )
+
+
 def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
     """Leave existing extra newlines if not `inside_brackets`. Remove everything
     else.
@@ -2951,6 +2972,7 @@ def ensure_visible(leaf: Leaf) -> None:
 
 def should_explode(line: Line, opening_bracket: Leaf) -> bool:
     """Should `line` immediately be split with `delimiter_split()` after RHS?"""
+
     if not (
         opening_bracket.parent
         and opening_bracket.parent.type in {syms.atom, syms.import_from}

